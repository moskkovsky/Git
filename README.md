> [!NOTE]
>это программное обеспечение, которое помогает отслеживать изменения в файлах проекта и управлять ими.

## Первоначальная настройка
> [!TIP]
> Необходимо настроить пользователя, чтобы git знал, кем подписывать коммиты.
```
git config --local user.name "Your Name"
git config --local user.email "email@example.com"
```

## Добавление файлов
```
git add <file> / git add . - добавление конкретного файла или всех в индексе
git add -p - добавить только часть изменений в определенном файле
```

## Логирование
> [!TIP]
> Команда используется для просмотра истории коммитов в репозитории. Она показывает последовательность всех коммитов, сделанных в проекте, включая авторов, даты и сообщения коммитов(хеш коммита (уникальный идентификатор),
имя автора и его электронный адрес, дату и время коммита, сообщение коммита)
```
git log - увидеть все коммиты, сделанные в репозитории, в порядке от самого последнего к самому раннему. 
git log -n 5 - увидеть последние 5 коммитов 
git log --author="author" - фильтрация по автору коммитов
git log --graph --oneline - визуализация структуры веток в проекте
git log --since="1 month ago" - увидеть за последний месяц коммиты
git log --grep="fix" - фильтровать логи по ключевым словам
git log --stat - показать статистику в коммите
```
## Коммиты
> [!TIP]
> Это запись неких характеристик, связанных с произошедшими изменениями в файле
```
git commit - длинный комментарий по изменениям в текстовом редакторе
git commit -m "comment" - добавления файлов с кратким комментарием
git commit --amend -m "comment" - исправление комментария (или добавления нового файла) в последний коммит
git commit -a -m "comment" - добавляет автоматически все измененнные файлы в индекс 
git commit --amend --no-edit - Чтобы внести изменения в последний коммит, сохранив его исходное сообщение.
```
Если забыл добавить файл в последний коммит
```
git add config.yml
git commit --amend
```
> [!TIP]
> Создается новый коммит, где будет видно, что отменили последние коммиты
```
git revert <hash commit> / git revert HEAD - отменяем последний коммит
git revert --no-edit <commit> - стандартное сообщение коммита 

```
## Удаленный репозиторий
> [!NOTE]
> upstream в Git — это установка связи между локальной ветвью и удалённой. Она позволяет синхронизировать два репозитория.
```
git mergetool - графический редактор для разрешения конфликтов
```
Слияние изменения из ветки hotfix в ветку main
```
git checkout main
git merge hotfix

git add file
git commit -m "Разрешение конфликта"
```
> [!TIP]
> Для создания локальной копии удалённого репозитория
```
git clone <url> - локальная копия удаленного репозитория
git clone <url> directory - склонировать проект в определенный репоризиторий
git clone -b <branch-name> <url> - склонировать проект и переключиться на определенную ветку
git clone --single-branch --branch <branch> <url> - склонировать репозиторий с определенными ветками
```
> [!TIP]
> Для работы с удаленным репозиторием
```
git remote -v - просмотр подключения к удаленным репозиториям
git remote add origin <url> - добавить новый удаленный репозиторий (используется по дефолту origin)
git remote rename origin upstream - rename имени удаленного репозитория
git remote remove origin - удаление ссылки на удаленный репозитория
git remote show origin - посмотреть информацию об удаленном репозитории
```
> [!TIP]
> Для получения изменений из удалённого репозитория и обновления локальных ссылок на удалённые ветки.
```
git fetch origin - Получаем обновления на ветки
git fetch origin <branch> - Подтянет изменения конкретно в этой ветке
git fetch --prune - Удаление веток которых в репозитории уже нет
```
> [!CAUTION]
> Загружает новые коммиты из удалённого репозитория, но не меняет ваш текущий код. **git pull** сразу обновляет ветки изменениями из репозитория (если изменения не пересекаются в одних и тех же файлах)
```
# Загружаем изменения с сервера
git fetch origin

# Смотрим, что изменилось в удалённой ветке
git log origin/main

# Вручную сливаем изменения (если нужно)
git merge origin/main
```
> [!TIP]
> Для отправки локальных изменений в удаленный репозиторий
```
git push origin main - залить изменения на ветку main в удаленный репозиторий
git push -u origin branch - опубликовать ветку на репозитории (-u делает связь в будущем чтобы позже сделать ветку по умолчанию при git push)
git push origin --delete branch - удаление ветки на репозитории
git checkout -b local-branch origin/local-branch
git push -u origin local-branch - делаем связь локальной ветки с удаленной из репозитория и ставим ее по умолчанию когда будет git push
git push --force origin main - принудительная отправка на ветку main
```
> [!TIP]
> Для получения изменений из удалённого репозитория и их автоматического объединения с локальной веткой.
```
git pull origin main - для получения изменений
```
## .gitignore
> [!TIP]
> Для указания файлов и директорий, которые не хотим, чтобы добавлялись в индекс при изменений в проекте
venv/
```
# игнор файлов cache python
__pycache__/
*.py[cod]

# временные файлы редакторов
*.swp
*.swo
*.~

# конфигурация idea
.idea/
.vscode/

# игнорирование всех логов
logs/
*.log

# игнорирвать все файлы кроме с расширением .log кроме файла logs.log
*.log
!logs.log

# различные не публичные данные
.env

# игнорирование всех файлов в этой директории
build/
dist/
*.egg-info/

# игнорирование файла
text.txt
```

## Работа с ветками
```
git branch -r - Показать все ветки в удаленном репозитории
git branch -m oldNameBranch newBranchName - rename ветки
git checkout -b new-branch - создать и переключиться на новую ветку
git checkout -- file.txt - убирает все изменения из локального файла до последнего коммита
git checkout -- . - отменить изменения которые еще не были добавлены в индекс
```
> [!TIP]
> Теги в Git используются для создания постоянных меток на конкретных коммитах, обычно для того, чтобы пометить важные вехи в истории проекта, такие как релизы версий.
```
git tag - просмотр тегов
git tag -d v1.0 - удаление тега
git tag -a v1.0 -m "release 1.0" - аннотированнйы тег (-a создаёт аннотированный тег с именем, -m добавляет сообщение)
git tag v1.0 - легкий тег с меткой указывающий на коммит
```
Чтобы локальную ветку в основную, необхомо перейти в основную ветку
```
git merge branch-to-merge
```
> [!TIP]
> Команда используется для отмены изменений в рабочем каталоге, возвращая файлы к состоянию последнего коммита
```
git restore <file> - возвращает файл к последнему коммиту
git restore --staged <file> - если добавили файл в индекс, то можно убрать командой
git restore . - отменить все изменения в рабочей директории
git restore --source=commit-hash <file> - вернет файл к указанному коммиту
```
> [!WARNING]
> Если ветка не слита с другой, то удалить ветку можно только с флагом -D
```
git branch -d/-D - удаление ветки, если ветка не слита, то флаг -D только ее удалит
```
> [!TIP]
> Позволяет откатывать изменения, которые уже были добавлены в индекс или даже закоммичены. В контексте разрешения конфликтов git reset помогает вернуться к предыдущему состоянию проекта и повторить процесс слияния или внесения изменений.
```
git reset --soft HEAD~2 - Откатывает указатель HEAD на нужный коммит, сохраняя все изменения как добавленные в индекс (staged). Это позволяет быстро откатить коммит и изменить его содержимое перед повторным коммитом.
git reset --hard HEAD~3 - Полностью откатывает указатель HEAD, индекс и рабочий каталог к указанному коммиту, удаляя все изменения, сделанные после него.
git reset ORIG_HEAD - Откатывает указатель HEAD и снимает все изменения с индекса, но оставляет их в рабочем каталоге. Это самый часто используемый вариант для отмены добавленных в индекс изменений, чтобы можно было внести правки перед повторной подготовкой.
```

## .geetkeep
> [!TIP]
> Используется для того, чтобы сохранить пустую директорию в репозитории. Git не отслеживает пустые директории, поэтому добавление файла уже будет видно в рабочей директории
```
mkdir directory
touch directory/.gitkeep
```

## git stash
> [!TIP]
> Используется для временного сохранения изменений, сделанных в рабочей директории, без необходимости коммитить их. Полезно, когда нужно переключиться на другую ветку или заняться другим заданием, но текущие изменения ещё не готовы к коммиту.
> [!WARNING]
> git stash сохраняет только файлы, которые были в индексе, неотслеживаемые файлы не сохраняет + не сохраняет игнорируемые файлы
```
git stash - команда сохраняет все незакоммиченные изменения (включая добавленные в индекс и просто изменённые файлы) в специальное хранилище
git stash save "message" - сохранение с сообщением
git stash list - для просмотра всех сохраненных изменений
git stash apply - вернуть из stash в рабочую директорию (но не удаляет из хранилища)
git stash pop - возвращает + удаляет из stash
git stash drop - удалить из stash
git stash -u - сохраняет файлы из индекса и неотслеживаемые файлы
git stash -a - сохраняет абсолютно все файлы, даже игнорируемые файлы
```

## git reflog
> [!TIP]
> Используется для отслеживания всех изменений всех изменений состояния указателя HEAD в репозитории.
```
git reflog - выводит список всех недавних изменений в указателе HEAD, включая информацию о коммитах
```
## git cherry-pick
> [!TIP]
> Команда используется для выбора одного или нескольких коммитов из одной ветки и применения их в другую ветку.
```
git cherry-pick <commit-sha> - влить коммит в текущую ветку
git cherry-pick <commit1-sha> <commit2-sha> - перенос нескольких коммитов

При конфликтов при cherry-pick необходимо продолжить выполенение команды
git add <conflicted-file>
git cherry-pick --continue

Если необходимо прервать процесс:
git cherry-pick --abort
git cherry-pick -e <commit> - изменение title коммита при вливании
```